/*
 * Copyright 2018 Intershop Communications AG.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intershop.gradle.javacc.task

import com.intershop.gradle.javacc.extension.JJTree
import com.intershop.gradle.javacc.extension.JavaCCExtension
import org.gradle.api.Action
import org.gradle.api.DefaultTask
import org.gradle.api.file.Directory
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.FileCollection
import org.gradle.api.file.RegularFile
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Nested
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.process.JavaForkOptions
import org.gradle.workers.WorkerExecutor
import java.io.File
import javax.inject.Inject

/**
 * Task implementation for JavaCC code generation.
 * The code will be generated by a worker executor.
 *
 * @constructor Creates a task with a worker.
 */
abstract class JavaCCTask @Inject constructor(private val workerExecutor: WorkerExecutor) : DefaultTask(){

    /**
     * Inject service of ObjectFactory (See "Service injection" in Gradle documentation.
     */
    @get:Inject
    abstract val objectFactory: ObjectFactory
    
    private val outputDirProperty: DirectoryProperty = objectFactory.directoryProperty()

    /**
     * Output dir for JavaCC code generation.
     *
     * @property outputDir
     */
    @get:OutputDirectory
    var outputDir: File
        get() = outputDirProperty.get().asFile
        set(value) = outputDirProperty.set(value)

    /**
     * Set provider for outputdir.
     *
     * @param outputDir
     */
    fun provideOutputDir(outputDir: Provider<Directory>) = outputDirProperty.set(outputDir)

    // Java CC configuration file
    private val inputFileProperty: RegularFileProperty = objectFactory.fileProperty()

    /**
     * Input file for code generation.
     *
     * @property inputFile
     */
    @get:InputFile
    var inputFile: File
        get() = inputFileProperty.get().asFile
        set(value) = inputFileProperty.set(value)

    /**
     * Set provider for inputFile.
     *
     * @param inputFile
     */
    fun provideInputFile(inputFile: Provider<RegularFile>) = inputFileProperty.set(inputFile)

    private val packageNameProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * This is the package name property of the
     * generated code.
     *
     * @property packageName
     */
    @get:Input
    var packageName: String
        get() = packageNameProperty.getOrElse("")
        set(value) = packageNameProperty.set(value)

    /**
     * Set provider for packageName.
     *
     * @param packageName
     */
    fun providePackageName(packageName: Provider<String>) = packageNameProperty.set(packageName)

    private val jdkVersionProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * JDK version property of the JavaCC code
     * generator.
     *
     * @property jdkVersion
     */
    @get:Optional
    @get:Input
    var jdkVersion: String?
        get() = jdkVersionProperty.orNull
        set(value) = jdkVersionProperty.set(value)

    /**
     * Set provider for jdkVersion.
     *
     * @param jdkVersion
     */
    fun provideJdkVersion(jdkVersion: Provider<String>) = jdkVersionProperty.set(jdkVersion)

    // property is a string, because there are problems with Integer and Int for the property
    private val lookaheadProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * LOOKAHEAD: The number of tokens to look ahead before making a decision at a choice point during parsing.
     * The smaller this number, the faster the parser. This number may be overridden for specific productions
     * within the grammar as described later.
     * This is the lookahead property of the parser configuration.
     *
     * @property lookahead
     */
    @get:Optional
    @get:Input
    var lookahead: Int?
        get() = lookaheadProperty.orNull?.toInt()
        set(value) = lookaheadProperty.set(value.toString())

    /**
     * Set provider for lookahead.
     *
     * @param lookahead
     */
    fun provideLookahead(lookahead: Provider<String>) = lookaheadProperty.set(lookahead)

    // property is a string, because there are problems with Integer and Int for the property
    private val choiceAmbiguityCheckProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * CHOICE_AMBIGUITY_CHECK: This is the number of tokens considered in
     * checking choices of the form "A \| B \| ..." for ambiguity.
     * This is the property for choiceAmbiguityCheck of the parser configuration.
     *
     * @property choiceAmbiguityCheck
     */
    @get:Optional
    @get:Input
    var choiceAmbiguityCheck: Int?
        get() = choiceAmbiguityCheckProperty.orNull?.toInt()
        set(value) = choiceAmbiguityCheckProperty.set(value.toString())

    /**
     * Set provider for choiceAmbiguityCheck.
     *
     * @param choiceAmbiguityCheck
     */
    fun provideChoiceAmbiguityCheck(choiceAmbiguityCheck: Provider<String>) =
            choiceAmbiguityCheckProperty.set(choiceAmbiguityCheck)

    // property is a string, because there are problems with Integer and Int for the property
    private val otherAmbiguityCheckProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * OTHER_AMBIGUITY_CHECK: This is the number of tokens considered in checking all
     * other kinds of choices (i.e., of the forms "(A)*", "(A)+", and "(A)?") for ambiguity.
     * This is the property otherAmbiguityCheck of the parser configuration.
     *
     * @property otherAmbiguityCheck
     */
    @get:Optional
    @get:Input
    var otherAmbiguityCheck: Int?
        get() = otherAmbiguityCheckProperty.orNull?.toInt()
        set(value) = otherAmbiguityCheckProperty.set(value.toString())

    /**
     * Set provider for otherAmbiguityCheck.
     *
     * @param otherAmbiguityCheck
     */
    fun provideOtherAmbiguityCheck(otherAmbiguityCheck: Provider<String>) =
            otherAmbiguityCheckProperty.set(otherAmbiguityCheck)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val staticParamProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * STATIC: If true, all methods and class variables are
     * specified as static in the generated parser and token manager.
     * This is the property staticParam of the parser configuration.
     *
     * @property staticParam
     */
    @get:Optional
    @get:Input
    var staticParam: String
        get() = staticParamProperty.getOrElse("")
        set(value) = staticParamProperty.set(value)

    /**
     * Set provider for staticParam.
     *
     * @param staticParam
     */
    fun provideStaticParam(staticParam: Provider<String>) = staticParamProperty.set(staticParam)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val supportClassVisibilityPublicProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * SUPPORT_CLASS_VISIBILITY_PUBLIC: The default action is to generate
     * support classes (such as Token.java, ParseException.java etc)
     * with Public visibility.
     * This is the property supportClassVisibilityPublic of the parser configuration.
     *
     * @property supportClassVisibilityPublic
     */
    @get:Optional
    @get:Input
    var supportClassVisibilityPublic: String
        get() = supportClassVisibilityPublicProperty.getOrElse("")
        set(value) = supportClassVisibilityPublicProperty.set(value)

    /**
     * Set provider for supportClassVisibilityPublic.
     *
     * @param supportClassVisibilityPublic
     */
    fun provideSupportClassVisibilityPublic(supportClassVisibilityPublic: Provider<String>) =
            supportClassVisibilityPublicProperty.set(supportClassVisibilityPublic)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val debugParserProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * DEBUG_PARSER: This option is used to obtain debugging
     * information from the generated parser.
     * This is the property debugParser of the parser configuration.
     *
     * @property debugParser
     */
    @get:Optional
    @get:Input
    var debugParser: String
        get() = debugParserProperty.getOrElse("")
        set(value) = debugParserProperty.set(value)

    /**
     * Set provider for debugParser.
     *
     * @param debugParser
     */
    fun provideDebugParser(debugParser: Provider<String>) = debugParserProperty.set(debugParser)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val debugLookaheadProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * DEBUG_LOOKAHEAD: Setting this option to true causes the parser
     * to generate all the tracing information it does when the option
     * DEBUG_PARSER is true.
     * This is the property debugLookahead of the parser configuration.
     *
     * @property debugLookahead
     */
    @get:Optional
    @get:Input
    var debugLookahead: String
        get() = debugLookaheadProperty.getOrElse("")
        set(value) = debugLookaheadProperty.set(value)

    /**
     * Set provider for debugLookahead.
     *
     * @param debugLookahead
     */
    fun provideDebugLookahead(debugLookahead: Provider<String>) = debugLookaheadProperty.set(debugLookahead)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val debugTokenManagerProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * DEBUG_TOKEN_MANAGER: This option is used to obtain debugging
     * information from the generated token manager.
     * This is the property debugTokenManager of the parser configuration.
     *
     * @property debugTokenManager
     */
    @get:Optional
    @get:Input
    var debugTokenManager: String
        get() = debugTokenManagerProperty.getOrElse("")
        set(value) = debugTokenManagerProperty.set(value)

    /**
     * Set provider for debugTokenManager.
     *
     * @param debugTokenManager
     */
    fun provideDebugTokenManager(debugTokenManager: Provider<String>) = debugTokenManagerProperty.set(debugTokenManager)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val errorReportingProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * ERROR_REPORTING: Setting it to false causes errors due to
     * parse errors to be reported in somewhat less detail.
     * This is the property errorReporting of the parser configuration.
     *
     * @property errorReporting
     */
    @get:Optional
    @get:Input
    var errorReporting: String
        get() = errorReportingProperty.getOrElse("")
        set(value) = errorReportingProperty.set(value)

    /**
     * Set provider for errorReporting.
     *
     * @param errorReporting
     */
    fun provideErrorReporting(errorReporting: Provider<String>) = errorReportingProperty.set(errorReporting)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val javaUnicodeEscapeProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * JAVA_UNICODE_ESCAPE: When set to true, the generated parser
     * uses an input stream object that processes Java Unicode
     * escapes (\u...) before sending characters to the token manager.
     * This is the property javaUnicodeEscape of the parser configuration.
     *
     * @property javaUnicodeEscape
     */
    @get:Optional
    @get:Input
    var javaUnicodeEscape: String
        get() = javaUnicodeEscapeProperty.getOrElse("")
        set(value) = javaUnicodeEscapeProperty.set(value)

    /**
     * Set provider for javaUnicodeEscape.
     *
     * @param javaUnicodeEscape
     */
    fun provideJavaUnicodeEscape(javaUnicodeEscape: Provider<String>) = javaUnicodeEscapeProperty.set(javaUnicodeEscape)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val unicodeInputProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * UNICODE_INPUT: When set to true, the generated parser uses
     * an input stream object that reads Unicode files.
     * This is the property unicodeInput of the parser configuration.
     *
     * @property unicodeInput
     */
    @get:Optional
    @get:Input
    var unicodeInput: String
        get() = unicodeInputProperty.getOrElse("")
        set(value) = unicodeInputProperty.set(value)

    /**
     * Set provider for unicodeInput.
     *
     * @param unicodeInput
     */
    fun provideUnicodeInput(unicodeInput: Provider<String>) = unicodeInputProperty.set(unicodeInput)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val ignoreCaseProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * IGNORE_CASE: Setting this option to true causes the generate
     * token manager to ignore case in the token specifications and
     * the input files.
     * This is the property ignoreCase of the parser configuration.
     *
     * @property ignoreCase
     */
    @get:Optional
    @get:Input
    var ignoreCase: String
        get() = ignoreCaseProperty.getOrElse("")
        set(value) = ignoreCaseProperty.set(value)

    /**
     * Set provider for ignoreCase.
     *
     * @param ignoreCase
     */
    fun provideIgnoreCase(ignoreCase: Provider<String>) = ignoreCaseProperty.set(ignoreCase)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val commonTokenActionProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * COMMON_TOKEN_ACTION: When set to true, every call to the token
     * manager's method "getNextToken" will cause a call to a used
     * defined method "CommonTokenAction" after the token has been
     * scanned in by the token manager.
     * This is the property commonTokenAction of the parser configuration.
     *
     * @property commonTokenAction
     */
    @get:Optional
    @get:Input
    var commonTokenAction: String
        get() = commonTokenActionProperty.getOrElse("")
        set(value) = commonTokenActionProperty.set(value)

    /**
     * Set provider for commonTokenAction.
     *
     * @param commonTokenAction
     */
    fun provideCommonTokenAction(commonTokenAction: Provider<String>) = commonTokenActionProperty.set(commonTokenAction)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val userTokenManagerProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * USER_TOKEN_MANAGER: The default action is to generate
     * a token manager that works on the specified grammar tokens.
     * This is the property userTokenManager of the parser configuration.
     *
     * @property userTokenManager
     */
    @get:Optional
    @get:Input
    var userTokenManager: String
        get() = userTokenManagerProperty.getOrElse("")
        set(value) = userTokenManagerProperty.set(value)

    /**
     * Set provider for userTokenManager.
     *
     * @param userTokenManager
     */
    fun provideUserTokenManager(userTokenManager: Provider<String>) = userTokenManagerProperty.set(userTokenManager)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val userCharStreamProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * USER_CHAR_STREAM: The default action is to generate
     * a character stream reader as specified by the options
     * JAVA_UNICODE_ESCAPE and UNICODE_INPUT.
     * This is the property userCharStream of the parser configuration.
     *
     * @property userCharStream
     */
    @get:Optional
    @get:Input
    var userCharStream: String
        get() = userCharStreamProperty.getOrElse("")
        set(value) = userCharStreamProperty.set(value)

    /**
     * Set provider for userCharStream.
     *
     * @param userCharStream
     */
    fun provideUserCharStream(userCharStream: Provider<String>) = userCharStreamProperty.set(userCharStream)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val buildParserProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * BUILD_PARSER: When set to false, the parser file is not generated.
     * This is the property buildParser of the parser configuration.
     *
     * @property buildParser
     */
    @get:Optional
    @get:Input
    var buildParser: String
        get() = buildParserProperty.getOrElse("")
        set(value) = buildParserProperty.set(value)

    /**
     * Set provider for buildParser.
     *
     * @param buildParser
     */
    fun provideBuildParser(buildParser: Provider<String>) = buildParserProperty.set(buildParser)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val buildTokenManagerProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * BUILD_TOKEN_MANAGER: When set to false the token manager file is not generated.
     * This is the property buildTokenManager of the parser configuration.
     *
     * @property buildTokenManager
     */
    @get:Optional
    @get:Input
    var buildTokenManager: String
        get() = buildTokenManagerProperty.getOrElse("")
        set(value) = buildTokenManagerProperty.set(value)

    /**
     * Set provider for buildTokenManager.
     *
     * @param buildTokenManager
     */
    fun provideBuildTokenManager(buildTokenManager: Provider<String>) = buildTokenManagerProperty.set(buildTokenManager)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val tokenManagerUsesParserProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * TOKEN_MANAGER_USES_PARSER: When set to true, the generated
     * token manager will include a field called parser that
     * references the instantiating parser instance.
     * This is the property tokenManagerUsesParser of the parser configuration.
     *
     * @property tokenManagerUsesParser
     */
    @get:Optional
    @get:Input
    var tokenManagerUsesParser: String
        get() = tokenManagerUsesParserProperty.getOrElse("")
        set(value) = tokenManagerUsesParserProperty.set(value)

    /**
     * Set provider for tokenManagerUsesParser.
     *
     * @param tokenManagerUsesParser
     */
    fun provideTokenManagerUsesParser(tokenManagerUsesParser: Provider<String>) =
            tokenManagerUsesParserProperty.set(tokenManagerUsesParser)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val sanityCheckProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * SANITY_CHECK: JavaCC performs many syntactic and semantic
     * checks on the grammar file during parser generation.
     * This is the property sanityCheck of the parser configuration.
     *
     * @property sanityCheck
     */
    @get:Optional
    @get:Input
    var sanityCheck: String
        get() = sanityCheckProperty.getOrElse("")
        set(value) = sanityCheckProperty.set(value)

    /**
     * Set provider for sanityCheck.
     *
     * @param sanityCheck
     */
    fun provideSanityCheck(sanityCheck: Provider<String>) = sanityCheckProperty.set(sanityCheck)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val forceLaCheckProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * FORCE_LA_CHECK: This option setting controls lookahead
     * ambiguity checking performed by JavaCC.
     * This is the property forceLaCheck of the parser configuration.
     *
     * @property forceLaCheck
     */
    @get:Optional
    @get:Input
    var forceLaCheck: String
        get() = forceLaCheckProperty.getOrElse("")
        set(value) = forceLaCheckProperty.set(value)

    /**
     * Set provider for forceLaCheck.
     *
     * @param forceLaCheck
     */
    fun provideForceLaCheck(forceLaCheck: Provider<String>) = forceLaCheckProperty.set(forceLaCheck)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val cacheTokensProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * CACHE_TOKENS: Setting this option to true causes
     * the generated parser to lookahead for extra tokens
     * ahead of time.
     * This is the property cacheTokens of the parser configuration.
     *
     * @property cacheTokens
     */
    @get:Optional
    @get:Input
    var cacheTokens: String
        get() = cacheTokensProperty.getOrElse("")
        set(value) = cacheTokensProperty.set(value)

    /**
     * Set provider for cacheTokens.
     *
     * @param cacheTokens
     */
    fun provideCacheTokens(cacheTokens: Provider<String>) = cacheTokensProperty.set(cacheTokens)

    /**
     * This property will interpreted as boolean if the value is not empty.
     */
    private val keepLineColumnProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * KEEP_LINE_COLUMN: If you set this option to false,
     * the generated CharStream will not have any
     * line/column tracking code.
     * This is the property keepLineColumn of the parser configuration.
     *
     * @property keepLineColumn
     */
    @get:Optional
    @get:Input
    var keepLineColumn: String
        get() = keepLineColumnProperty.getOrElse("")
        set(value) = keepLineColumnProperty.set(value)

    /**
     * Set provider for keepLineColumn.
     *
     * @param keepLineColumn
     */
    fun provideKeepLineColumn(keepLineColumn: Provider<String>) = keepLineColumnProperty.set(keepLineColumn)

    private val tokenExtendsProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * TOKEN_EXTENDS: This is a string option whose default
     * value is "", meaning that the generated Token class
     * will extend java.lang.Object.
     * This is the property tokenExtends of the parser configuration.
     *
     * @property tokenExtends
     */
    @get:Optional
    @get:Input
    var tokenExtends: String
        get() = tokenExtendsProperty.getOrElse("")
        set(value) = tokenExtendsProperty.set(value)

    /**
     * Set provider for tokenExtends.
     *
     * @param tokenExtends
     */
    fun provideTokenExtends(tokenExtends: Provider<String>) = tokenExtendsProperty.set(tokenExtends)

    private val tokenFactoryProperty: Property<String> = objectFactory.property(String::class.java)

    /**
     * TOKEN_FACTORY: This is a string option whose default
     * value is "", meaning that Tokens will be created
     * by calling Token.newToken().
     * This is the property tokenFactory of the parser configuration.
     *
     * @property tokenFactory
     */
    @get:Optional
    @get:Input
    var tokenFactory: String?
        get() = tokenFactoryProperty.orNull
        set(value) = tokenFactoryProperty.set(value)

    /**
     * Set provider for tokenFactory.
     *
     * @param tokenFactory
     */
    fun provideTokenFactory(tokenFactory: Provider<String>) = tokenFactoryProperty.set(tokenFactory)

    private val javaCCArgsProperty: ListProperty<String> = objectFactory.listProperty(String::class.java)

    /**
     * Property with additional command
     * line arguments passed to javaCC.
     *
     * @property javaCCArgs
     */
    @get:Optional
    @get:Input
    var javaCCArgs: List<String>
        get() =  javaCCArgsProperty.get()
        set(value) = javaCCArgsProperty.set(value)

    /**
     * Set provider for javaCCArgs.
     *
     * @param javaCCArgs
     */
    fun provideJavaCCArgs(javaCCArgs: Provider<List<String>>) = javaCCArgsProperty.set(javaCCArgs)

    /**
     * JJTree configuration container.
     *
     * @property jjTree
     */
    @get:Optional
    @get:Nested
    var jjTree: JJTree? = null

    /**
     * Classpath with javaCC libraries.
     */
    @get:InputFiles
    val toolsclasspathfiles : FileCollection by lazy {
        val returnFiles = project.files()
        // find files of original JASPER and Eclipse compiler
        returnFiles.from(project.configurations.findByName(JavaCCExtension.JAVACC_CONFIGURATION_NAME))
        returnFiles
    }

    /**
     * Java fork options for the Java task.
     */
    private var internalForkOptionsAction: Action<in JavaForkOptions>? = null

    /**
     * Set the fork options for the code
     * generation java process.
     */
    fun forkOptions(forkOptionsAction: Action<in JavaForkOptions>) {
        internalForkOptionsAction = forkOptionsAction
    }

    /**
     * Task aktion for code generation.
     */
    @TaskAction
    fun generate() {
        val outDir: File = if(packageName.isBlank()) {
            outputDir
        } else {
            File(outputDir, packageName.replace('.', '/')) }

        val workQueue = workerExecutor.processIsolation() {
            it.classpath.setFrom(toolsclasspathfiles)

            if(internalForkOptionsAction != null) {
                project.logger.debug("Add configured JavaForkOptions for JavaCC compile runner.")
                internalForkOptionsAction?.execute(it.forkOptions)
            }
        }

        // start runner
        workQueue.submit(JavaCCRunner::class.java) {
            it.outputDir.set(outDir)
            it.inputFile.set(inputFile)
            it.javaCCParamList.set(calculateJavaCCParameterList())
            it.jjTreeParamList.set(calculateJJTreeParameterList())
        }

        workerExecutor.await()
    }

    private fun calculateJJTreeParameterList() : List<String> {
        val paramlist: MutableList<String> = mutableListOf()

        if(jjTree != null && (jjTree as JJTree).isConfigured) {
            val pJJTree: JJTree = jjTree as JJTree

            addBooleanParameter(paramlist,"BUILD_NODE_FILES", pJJTree.buildNodeFiles)
            addBooleanParameter(paramlist,"MULTI", pJJTree.multi)
            addBooleanParameter(paramlist,"NODE_DEFAULT_VOID", pJJTree.nodeDefaultVoid)
            addBooleanParameter(paramlist,"NODE_SCOPE_HOOK", pJJTree.nodeScopeHook)
            addBooleanParameter(paramlist,"NODE_USES_PARSER", pJJTree.nodeUsesParser)
            addBooleanParameter(paramlist,"TRACK_TOKENS", pJJTree.trackTokens)
            addBooleanParameter(paramlist,"VISITOR", pJJTree.visitor)
            addBooleanParameter(paramlist,"STATIC", pJJTree.staticParam)

            addStringParameter(paramlist, "NODE_CLASS", pJJTree.nodeClass)
            addStringParameter(paramlist, "NODE_PREFIX", pJJTree.nodePrefix)
            addStringParameter(paramlist, "NODE_EXTENDS", pJJTree.nodeExtends)
            addStringParameter(paramlist, "NODE_PACKAGE", pJJTree.nodePackage)
            addStringParameter(paramlist, "NODE_FACTORY", pJJTree.nodeFactory)
            addStringParameter(paramlist, "VISITOR_DATA_TYPE", pJJTree.visitorDataType)
            addStringParameter(paramlist, "VISITOR_RETURN_TYPE", pJJTree.visitorReturnType)
            addStringParameter(paramlist, "VISITOR_EXCEPTION", pJJTree.visitorException)

            addStringParameter(paramlist, "JDK_VERSION", jdkVersion)

            pJJTree.args.forEach {
                paramlist.add(it)
            }
        }

        return paramlist
    }

    private fun calculateJavaCCParameterList() : List<String> {
        val paramlist: MutableList<String> = mutableListOf()

        addBooleanParameter(paramlist,"STATIC", staticParam)
        addBooleanParameter(paramlist,"SUPPORT_CLASS_VISIBILITY_PUBLIC", supportClassVisibilityPublic)
        addBooleanParameter(paramlist,"DEBUG_PARSER", debugParser)
        addBooleanParameter(paramlist,"DEBUG_LOOKAHEAD", debugLookahead)
        addBooleanParameter(paramlist,"DEBUG_TOKEN_MANAGER", debugTokenManager)
        addBooleanParameter(paramlist,"ERROR_REPORTING", errorReporting)
        addBooleanParameter(paramlist,"JAVA_UNICODE_ESCAPE", javaUnicodeEscape)
        addBooleanParameter(paramlist,"UNICODE_INPUT", unicodeInput)
        addBooleanParameter(paramlist,"IGNORE_CASE", ignoreCase)
        addBooleanParameter(paramlist,"COMMON_TOKEN_ACTION", commonTokenAction)
        addBooleanParameter(paramlist,"USER_TOKEN_MANAGER", userTokenManager)
        addBooleanParameter(paramlist,"USER_CHAR_STREAM", userCharStream)
        addBooleanParameter(paramlist,"BUILD_PARSER", buildParser)
        addBooleanParameter(paramlist,"BUILD_TOKEN_MANAGER", buildTokenManager)
        addBooleanParameter(paramlist,"TOKEN_MANAGER_USES_PARSER", tokenManagerUsesParser)
        addBooleanParameter(paramlist,"SANITY_CHECK", sanityCheck)
        addBooleanParameter(paramlist,"FORCE_LA_CHECK", forceLaCheck)
        addBooleanParameter(paramlist,"CACHE_TOKENS", cacheTokens)
        addBooleanParameter(paramlist,"KEEP_LINE_COLUMN", keepLineColumn)

        addIntegerParameter(paramlist, "CHOICE_AMBIGUITY_CHECK", choiceAmbiguityCheck)
        addIntegerParameter(paramlist, "OTHER_AMBIGUITY_CHECK", otherAmbiguityCheck)
        addIntegerParameter(paramlist, "LOOKAHEAD", lookahead)

        addStringParameter(paramlist, "TOKEN_EXTENDS", tokenExtends)
        addStringParameter(paramlist, "TOKEN_FACTORY", tokenFactory)
        addStringParameter(paramlist, "JDK_VERSION", jdkVersion)

        javaCCArgs.forEach {
            paramlist.add(it)
        }

        return paramlist
    }

    private fun addStringParameter(paramList: MutableList<String>, paramName: String, paramValue: String?) {
        if(paramValue != null) {
            paramList.add("-$paramName=$paramValue")
        }
    }

    private fun addIntegerParameter(paramList: MutableList<String>, paramName: String, paramValue: Int?) {
        if(paramValue != null) {
            paramList.add("-$paramName=$paramValue")
        }
    }

    private fun addBooleanParameter(paramList: MutableList<String>, paramName: String, paramValue: String) {
        if(paramValue.isNotBlank()) {
            paramList.add("-$paramName=${paramValue.toBoolean()}")
        }
    }
}
